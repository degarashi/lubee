diff --git a/dumper.py b/dumper.py
index 564b87a..502d0dd 100644
--- a/dumper.py
+++ b/dumper.py
@@ -35,6 +35,7 @@ import time
 import json
 import inspect
 import threading
+import gdb
 
 if sys.version_info[0] >= 3:
     xrange = range
@@ -133,6 +134,14 @@ def arrayForms():
 def mapForms():
     return [CompactMapFormat]
 
+def lb_SetNative(dumper, dst, nv):
+    dst.native = nv
+    dst.d = dumper
+    return dst
+def lb_GetArrayNative(d, ptr, typ):
+    TP = d.lookupNativeType(typ.name + "*")
+    A = gdb.Value(ptr).cast(TP)
+    return lb_SetNative(d, d.createValue(ptr, typ), A.dereference())
 
 class ReportItem:
     """
@@ -2184,7 +2193,8 @@ class DumperBase:
             with Children(self, n, innerType, childNumChild, maxNumChild,
                     addrBase=addrBase, addrStep=innerSize):
                 for i in self.childRange():
-                    self.putSubItem(i, self.createValue(addrBase + i * innerSize, innerType))
+                    ptr = addrBase + i * innerSize
+                    self.putSubItem(i, lb_GetArrayNative(self, ptr, innerType))
 
     def putArrayItem(self, name, addr, n, typeName):
         self.checkIntType(addr)
@@ -2856,6 +2866,7 @@ class DumperBase:
             self.targetValue = None # For references.
             self.isBaseClass = None
             self.nativeValue = None
+            self.native = None
 
         def copy(self):
             val = self.dumper.Value(self.dumper)
@@ -2870,6 +2881,7 @@ class DumperBase:
             val.lbitsize = self.lbitsize
             val.targetValue = self.targetValue
             val.nativeValue = self.nativeValue
+            val.native = self.native
             return val
 
         def check(self):
@@ -2993,7 +3005,7 @@ class DumperBase:
             if self.type.code == TypeCodeTypedef:
                 return self.findMemberByName(self.detypedef())
             if self.type.code in (TypeCodePointer, TypeCodeReference):
-                res = self.dereference().findMemberByName(name)
+                res = lb_SetNative(self.dumper, self.dereference(), self.native.dereference()).findMemberByName(name)
                 if res is not None:
                     return res
             if self.type.code == TypeCodeStruct:
@@ -3037,10 +3049,10 @@ class DumperBase:
             elif self.dumper.isInt(index):
                 if self.type.code == TypeCodeArray:
                     addr = self.laddress + int(index) * self.type.ltarget.size()
-                    return self.dumper.createValue(addr, self.type.ltarget)
+                    return lb_SetNative(self.dumper, self.dumper.createValue(addr, self.type.ltarget), self.native[index])
                 if self.type.code == TypeCodePointer:
                     addr = self.pointer() + int(index) * self.type.ltarget.size()
-                    return self.dumper.createValue(addr, self.type.ltarget)
+                    return lb_SetNative(self.dumper, self.dumper.createValue(addr, self.type.ltarget), self.native[index])
                 return self.members(False)[index]
             else:
                 error('BAD INDEX TYPE %s' % type(index))
@@ -3079,7 +3091,7 @@ class DumperBase:
                     val.laddress = self.laddress
                 if self.ldata is not None:
                     val.ldata = self.ldata
-                return val
+                return lb_SetNative(self.dumper, val, self.native)
 
             fieldBitsize = field.bitsize
             fieldSize = (fieldBitsize + 7) // 8
@@ -3115,6 +3127,12 @@ class DumperBase:
                 if val.laddress is not None:
                     val = self.dumper.createReferenceValue(val.laddress, fieldType.ltarget)
                     val.name = field.name
+            try:
+               self.native[field.name]
+            except:
+               val.native = self.native
+            else:
+               val.native = self.native[field.name]
 
             #warn('GOT VAL %s FOR FIELD %s' % (val, field))
             val.lbitsize = fieldBitsize
@@ -3145,7 +3163,7 @@ class DumperBase:
             for field in fields:
                 if isinstance(field, self.dumper.Value):
                     #warn("USING VALUE DIRECTLY %s" % field.name)
-                    res.append(field)
+                    res.append(lb_SetNative(self.dumper, field, self.native[field.name]))
                     continue
                 if field.isBase and not includeBases:
                     #warn("DROPPING BASE %s" % field.name)
@@ -3178,7 +3196,7 @@ class DumperBase:
         def dereference(self):
             self.check()
             if self.type.code == TypeCodeTypedef:
-                return self.detypedef().dereference()
+                return lb_SetNative(self.dumper, self.detypedef().dereference(), self.native.dereference())
             val = self.dumper.Value(self.dumper)
             if self.type.code == TypeCodeReference:
                 if self.nativeValue is None:
@@ -3201,7 +3219,7 @@ class DumperBase:
             #dynTypeName = val.type.dynamicTypeName(val.laddress)
             #if dynTypeName is not None:
             #    val.type = self.dumper.createType(dynTypeName)
-            return val
+            return lb_SetNative(self.dumper, val, self.native)
 
         def detypedef(self):
             self.check()
@@ -3238,7 +3256,7 @@ class DumperBase:
             val.lbitsize = self.lbitsize
             val.ldata = self.ldata
             val.type = self.dumper.createType(typish)
-            return val
+            return lb_SetNative(self.dumper, val, self.native.cast(self.d.lookupNativeType(typish.name)))
 
         def address(self):
             self.check()
diff --git a/gdbbridge.py b/gdbbridge.py
index 0f171a4..baa405f 100644
--- a/gdbbridge.py
+++ b/gdbbridge.py
@@ -225,6 +225,7 @@ class Dumper(DumperBase):
             val = self.createReferenceValue(toInteger(nativeValue.address), targetType)
             val.nativeValue = nativeValue
             #warn('CREATED REF: %s' % val)
+            val.native = nativeValue
             return val
         if code == gdb.TYPE_CODE_PTR:
             try:
@@ -238,6 +239,7 @@ class Dumper(DumperBase):
             if not nativeValue.address is None:
                 val.laddress = toInteger(nativeValue.address)
             #warn('CREATED PTR 2: %s' % val)
+            val.native = nativeValue
             return val
         if code == gdb.TYPE_CODE_TYPEDEF:
             targetType = nativeType.strip_typedefs().unqualified()
@@ -252,6 +254,7 @@ class Dumper(DumperBase):
             val.type = self.fromNativeType(nativeType)
             val.nativeValue = nativeValue
             #warn('CREATED TYPEDEF: %s' % val)
+            val.native = nativeValue
             return val
 
         val = self.Value(self)
@@ -270,6 +273,7 @@ class Dumper(DumperBase):
                     pass
             val.ldata = bytes(buf)
 
+        val.native = nativeValue
         val.type = self.fromNativeType(nativeType)
         val.lIsInScope = not nativeValue.is_optimized_out
         code = nativeType.code
diff --git a/stdtypes.py b/stdtypes.py
index cf8b976..31d2601 100644
--- a/stdtypes.py
+++ b/stdtypes.py
@@ -69,8 +69,12 @@ def qdump__std__deque(d, value):
     if innerSize < 512:
         bufsize = 512 // innerSize
 
+    m_start = value["_M_start"]
+    m_finish = value["_M_finish"]
     (mapptr, mapsize, startCur, startFirst, startLast, startNode,
-              finishCur, finishFirst, finishLast, finishNode) = value.split("pppppppppp")
+              finishCur, finishFirst, finishLast, finishNode) = (value["_M_map"].pointer(), value["_M_map_size"].pointer(),
+        m_start["_M_cur"].pointer(), m_start["_M_first"].pointer(), m_start["_M_last"].pointer(), m_start["_M_node"].pointer(),
+        m_finish["_M_cur"].pointer(), m_finish["_M_first"].pointer(), m_finish["_M_last"].pointer(), m_finish["_M_node"].pointer())
 
     size = bufsize * ((finishNode - startNode) // d.ptrSize() - 1)
     size += (finishCur - finishFirst) // innerSize
@@ -181,22 +185,13 @@ def qdump__std__list(d, value):
         qdump__std__list__QNX(d, value)
         return
 
-    if value.type.size() == 3 * d.ptrSize():
-        # C++11 only.
-        (dummy1, dummy2, size) = value.split("ppp")
-        d.putItemCount(size)
-    else:
-        # Need to count manually.
-        p = d.extractPointer(value)
-        head = value.address()
-        size = 0
-        while head != p and size < 1001:
-            size += 1
-            p = d.extractPointer(p)
-        d.putItemCount(size, 1000)
+    # C++11 only.
+    node = value["_M_node"]
+    (dummy1, dummy2, size) = (node["_M_next"].pointer(), node["_M_prev"].pointer(), node["_M_data"].pointer())
+    d.putItemCount(size)
 
     if d.isExpanded():
-        p = d.extractPointer(value)
+        p = d.extractPointer(node["_M_next"])
         innerType = value.type[0]
         with Children(d, size, maxNumChild=1000, childType=innerType):
             for i in d.childRange():
@@ -704,15 +699,12 @@ def qdump__std____1__unique_ptr(d, value):
 
 
 def qdump__std__pair(d, value):
-    typeCode = '{%s}@{%s}' % (value.type[0].name, value.type[1].name)
-    first, pad, second = value.split(typeCode)
+    first, second = value["first"], value["second"]
+    first.native, second.native = value.native["first"], value.native["second"]
     with Children(d):
         key = d.putSubItem('first', first)
         value = d.putSubItem('second', second)
-    d.putField('key', key.value)
-    if key.encoding is not None:
-        d.putField('keyencoded', key.encoding)
-    d.putValue(value.value, value.encoding)
+    d.putType(first)
 
 def qform__std__unordered_map():
     return mapForms()
@@ -729,16 +721,19 @@ def qdump__std__unordered_map(d, value):
         # gcc ~= 4.7
         size = value["_M_element_count"].integer()
         start = value["_M_before_begin"]["_M_nxt"]
+        offset = 0
     except:
         try:
             # libc++ (Mac)
             size = value["_M_h"]["_M_element_count"].integer()
             start = value["_M_h"]["_M_bbegin"]["_M_node"]["_M_nxt"]
+            offset = 0
         except:
             try:
                 # gcc 4.9.1
                 size = value["_M_h"]["_M_element_count"].integer()
                 start = value["_M_h"]["_M_before_begin"]["_M_nxt"]
+                offset = 0
             except:
                 # gcc 4.6.2
                 size = value["_M_element_count"].integer()
@@ -747,18 +742,20 @@ def qdump__std__unordered_map(d, value):
                 d.putItemCount(size)
                 # We don't know where the data is
                 d.putNumChild(0)
+                offset = d.ptrSize()
                 return
 
     d.putItemCount(size)
     if d.isExpanded():
-        keyType = value.type[0]
-        valueType = value.type[1]
-        typeCode = 'p@{%s}@{%s}' % (value.type[0].name, value.type[1].name)
+        T = d.lookupNativeType(value.type.name + "::value_type")
+        T2 = d.fromNativeType(T)
+        ptrSize = d.ptrSize()
         p = start.pointer()
         with Children(d, size):
             for i in d.childRange():
-                p, pad, key, pad, val = d.split(typeCode, p)
-                d.putPairItem(i, (key, val))
+                ptr = p + ptrSize - offset
+                d.putSubItem(i, lb_GetArrayNative(d, ptr, T2))
+                p = d.extractPointer(p)
 
 def qdump__std____debug__unordered_map(d, value):
     qdump__std__unordered_map(d, value)
@@ -807,12 +804,14 @@ def qdump__std__unordered_set(d, value):
 
     d.putItemCount(size)
     if d.isExpanded():
+        T = d.lookupNativeType(value.type.name + "::value_type")
+        T2 = d.fromNativeType(T)
         p = start.pointer()
-        valueType = value.type[0]
-        with Children(d, size, childType=valueType):
+        with Children(d, size, childType=T2):
             ptrSize = d.ptrSize()
             for i in d.childRange():
-                d.putSubItem(i, d.createValue(p + ptrSize - offset, valueType))
+                ptr = p + ptrSize - offset
+                d.putSubItem(i, lb_GetArrayNative(d, ptr, T2))
                 p = d.extractPointer(p + offset)
 
 def qform__std____1__unordered_map():
@@ -912,7 +911,9 @@ def qdumpHelper__std__vector(d, value, isLibCpp):
             (start, soffset, pad, finish, foffset, pad, alloc) = value.split("pI@pI@p")
             size = (finish - start) * 8 + foffset - soffset # 8 is CHAR_BIT.
     else:
-        (start, finish, alloc) = value.split("ppp")
+        start = value["_M_start"].pointer()
+        finish = value["_M_finish"].pointer()
+        alloc = value["_M_end_of_storage"].pointer()
         size = int((finish - start) / innerType.size())
         d.check(finish <= alloc)
         if size > 0:
